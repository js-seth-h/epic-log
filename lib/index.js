// Generated by CoffeeScript 1.10.0
var CODE_SPACE, EpicLog, LV_DEBUG, LV_FATAL, LV_INFO, LV_LOG, LV_VERB, LV_WARN, _createScope, _isArray, _isError, _isFunction, _isNumeric, _isObject, _isString, createConsoleWriter, createFileWriter, createFilter, debug, emitter, events, exports, fixStr, randomCode, yyyymmdd,
  slice = [].slice,
  hasProp = {}.hasOwnProperty;

events = require('events');

debug = require('debug')('epic-log');

_isNumeric = function(obj) {
  return !_isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
};

_isString = function(obj) {
  return typeof obj === 'string' || obj instanceof String;
};

_isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

_isFunction = function(obj) {
  return !!(obj && obj.constructor && obj.call && obj.apply);
};

_isObject = function(obj) {
  return !!obj && obj.constructor === Object;
};

_isError = function(obj) {
  return obj instanceof Error;
};

LV_FATAL = 'fatal';

LV_WARN = 'warn';

LV_INFO = 'info';

LV_VERB = 'verb';

LV_LOG = 'log';

LV_DEBUG = 'debug';

emitter = new events.EventEmitter();

fixStr = function(str, emptyStr) {
  var t;
  t = str + emptyStr;
  return t.slice(0, emptyStr.length);
};

createFilter = function() {
  var filter;
  filter = {
    cached_enabled: {},
    skips: [],
    names: [],
    clear: function() {
      filter.cached_enabled = {};
      filter.skips = [];
      return filter.names = [];
    },
    build: function(namespaces) {
      var i, len, namespace, pat, results, split;
      split = (namespaces || '').split(/[\s,]+/);
      len = split.length;
      i = 0;
      results = [];
      while (i < len) {
        if (!split[i]) {
          i++;
          continue;
        }
        namespace = split[i].replace(/\*/g, '.*?');
        pat = filter.names;
        if (namespace[0] === '-') {
          pat = filter.skips;
          namespace = namespace.substr(1);
        }
        pat.push(new RegExp('^' + namespace + '$'));
        results.push(i++);
      }
      return results;
    },
    enabled: function(name) {
      var _enabled;
      _enabled = function(name) {
        var i, len;
        i = void 0;
        len = void 0;
        i = 0;
        len = filter.skips.length;
        while (i < len) {
          if (filter.skips[i].test(name)) {
            return false;
          }
          i++;
        }
        i = 0;
        len = filter.names.length;
        while (i < len) {
          if (filter.names[i].test(name)) {
            return true;
          }
          i++;
        }
        return false;
      };
      if (filter.cached_enabled[name] === void 0) {
        filter.cached_enabled[name] = _enabled(name);
      }
      debug('check enabled', name, filter.cached_enabled[name]);
      return filter.cached_enabled[name];
    }
  };
  return filter;
};

CODE_SPACE = 'ABCDEFGHJKMNPQRSTVWXYZ1234567890';

randomCode = function(size) {
  var at, inx, j, ref, result;
  result = '';
  for (inx = j = 0, ref = size; 0 <= ref ? j < ref : j > ref; inx = 0 <= ref ? ++j : --j) {
    at = Math.floor(CODE_SPACE.length * Math.random());
    result += CODE_SPACE[at];
  }
  return result;
};

_createScope = function(parentScope, subScope, useId) {
  var newScope, scopeLog;
  if (parentScope == null) {
    parentScope = null;
  }
  if (subScope == null) {
    subScope = null;
  }
  if (useId == null) {
    useId = false;
  }
  if (subScope === null) {
    subScope = randomCode(4);
    useId = false;
  }
  if (useId === true) {
    subScope += "(" + (randomCode(4)) + ")";
  }
  newScope = parentScope + ':' + subScope;
  if (!parentScope) {
    newScope = subScope;
  }
  scopeLog = EpicLog(newScope);
  return scopeLog;
};

EpicLog = function(scope) {
  var _createLoggingFn, epic;
  _createLoggingFn = function(lv) {
    var _fn, fn1, inx, j, len1, ref, v;
    _fn = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return EpicLog.write(lv, scope, args);
    };
    ref = '-=*';
    fn1 = function(v, inx) {
      return _fn['hr' + inx] = function(title, barLen) {
        var bar;
        if (title == null) {
          title = '';
        }
        if (barLen == null) {
          barLen = 25;
        }
        bar = new Array(barLen).join(v);
        if (!title) {
          title = new Array(10).join(v);
        } else {
          title = "  " + title + "  ";
        }
        return _fn(bar + title + bar);
      };
    };
    for (inx = j = 0, len1 = ref.length; j < len1; inx = ++j) {
      v = ref[inx];
      fn1(v, inx);
    }
    _fn.hr = _fn.hr0;
    return _fn;
  };
  epic = {
    fatal: _createLoggingFn(LV_FATAL),
    warn: _createLoggingFn(LV_WARN),
    info: _createLoggingFn(LV_INFO),
    verb: _createLoggingFn(LV_VERB),
    log: _createLoggingFn(LV_LOG),
    debug: _createLoggingFn(LV_DEBUG),
    scope: function(subScope, useId) {
      if (subScope == null) {
        subScope = null;
      }
      if (useId == null) {
        useId = false;
      }
      return _createScope(scope, subScope, useId);
    },
    using: function(fnInScope) {
      return fnInScope(epic);
    },
    lig: function(obj) {
      var fn, fnName, results;
      results = [];
      for (fnName in epic) {
        if (!hasProp.call(epic, fnName)) continue;
        fn = epic[fnName];
        results.push(obj[fnName] = fn);
      }
      return results;
    }
  };
  return epic;
};

EpicLog.fixStr = fixStr;

EpicLog.create = function(scope) {
  return EpicLog(scope);
};

EpicLog.scope = function(scope, useId) {
  return _createScope(null, scope, useId);
};

EpicLog.configure = function(conf) {
  var cfg, fs;
  debug('configure');
  if (conf.filepath) {
    fs = require('fs');
    EpicLog.watcher = fs.watch(conf.filepath, function(evt, fn) {
      fs.readFile(conf.filepath, function(err, data) {
        EpicLog.conf = JSON.parse(data);
        return EpicLog.build();
      });
    });
    cfg = fs.readFileSync(conf.filepath);
    EpicLog.conf = JSON.parse(cfg);
  } else {
    EpicLog.conf = conf;
  }
  return EpicLog.build();
};

EpicLog.build = function() {
  var conf, k, ref, results, v;
  debug('build');
  conf = EpicLog.conf;
  emitter.removeAllListeners();
  ref = conf.writer;
  results = [];
  for (k in ref) {
    if (!hasProp.call(ref, k)) continue;
    v = ref[k];
    if (v === false) {
      continue;
    }
    if (v === true && EpicLog.writerFactory[k]) {
      results.push(EpicLog.setWriter(EpicLog.writerFactory[k](conf[k])));
    } else {
      results.push(EpicLog.setWriter(v));
    }
  }
  return results;
};

EpicLog.setWriter = function(writer) {
  return emitter.on('write', writer);
};

EpicLog.write = function(lv, scope, args) {
  var localISOTime, now, tzoffset;
  now = new Date();
  tzoffset = now.getTimezoneOffset() * 60000;
  localISOTime = (new Date(now.getTime() - tzoffset)).toISOString().slice(0, -1).replace('T', ' ');
  return emitter.emit('write', lv, localISOTime, scope, args);
};

EpicLog.toText = function(lv, dt, scope, args, opt) {
  var a, aInx, attach, body, header, j, len1, lines, ll, msg, pad, padLen, stack, str, util;
  if (opt == null) {
    opt = {};
  }
  util = require('util');
  padLen = 5 - lv.length;
  pad = '       '.slice(0, padLen);
  opt.decoDate = opt.decoDate || function(t) {
    return t;
  };
  opt.decoLv = opt.decoLv || function(t) {
    return t;
  };
  opt.decoScope = opt.decoScope || function(t) {
    return t;
  };
  opt.decoBody = opt.decoBody || function(t) {
    return t;
  };
  opt.inspectColor = opt.inspectColor || false;
  header = "[" + (opt.decoDate(dt)) + "] " + pad + "[" + (opt.decoLv(lv)) + "] [" + (opt.decoScope(scope)) + "] ";
  body = '';
  attach = '';
  aInx = 0;
  for (j = 0, len1 = args.length; j < len1; j++) {
    a = args[j];
    if (!('object' === typeof a) && !('function' === typeof a)) {
      body += " " + a;
    } else if (_isError(a)) {
      msg = a.toString();
      stack = a.stack;
      if (opt.decoErr) {
        stack = opt.decoErr(stack);
      }
      body += msg;
      attach += "\n$err:= \n" + stack;
      if (a.hint) {
        attach += "\n$hint:=" + util.inspect(a.hint);
      }
    } else {
      body += " $" + aInx;
      if (_isFunction(a)) {
        str = a.toString(2);
      } else {
        str = util.inspect(a, {
          showHidden: false,
          depth: 10,
          colors: opt.inspectColor
        });
      }
      if (lv !== LV_DEBUG && opt.limitAttachLine) {
        lines = str.split("\n");
        if (lines.length > opt.limitAttachLine) {
          ll = lines.length;
          str = lines.slice(0, opt.limitAttachLine).join("\n") + ("\n------  MORE (" + opt.limitAttachLine + " of " + ll + " lines)  ------");
        }
      }
      attach += ("\n$" + aInx + ":= ") + str;
      aInx++;
    }
  }
  body = body + attach;
  body = body.split("\n").map(function(l) {
    return "     " + l;
  }).join("\n").trim();
  body = opt.decoBody(body);
  return header + body;
};

yyyymmdd = function(dt) {
  var dd, mm, yyyy;
  yyyy = dt.getFullYear().toString();
  mm = (dt.getMonth() + 1).toString();
  dd = dt.getDate().toString();
  if (mm.length === 1) {
    mm = "0" + mm;
  }
  if (dd.length === 1) {
    dd = "0" + dd;
  }
  return yyyy + mm + dd;
};

createFileWriter = function() {
  var _appendToFile, _writer, bufLine, fs, lock, truncated;
  fs = require('fs');
  debug('createFileWriter');
  bufLine = [];
  lock = false;
  truncated = false;
  if (!EpicLog.conf.file.filename) {
    EpicLog.conf.file.filename = function(fileYMD) {
      return EpicLog.conf.file.prefix + fileYMD + ".txt";
    };
  }
  _appendToFile = function() {
    var YMD, args, data, dt, fileYMD, filename, line, lv, scope, text;
    if (lock) {
      return;
    }
    if (bufLine.length === 0) {
      return;
    }
    lock = true;
    if (EpicLog.conf.file.truncate === true && truncated === false) {
      fileYMD = yyyymmdd(new Date());
      filename = EpicLog.conf.file.filename(fileYMD);
      if (fs.existsSync(filename)) {
        fs.truncateSync(filename, 0);
      }
      truncated = true;
    }
    data = '';
    fileYMD = null;
    while (true) {
      line = bufLine.shift();
      lv = line[0], dt = line[1], scope = line[2], args = line[3];
      YMD = dt.slice(0, 10).replace(/-/gi, '');
      if (fileYMD === null) {
        fileYMD = YMD;
      } else if (fileYMD !== YMD) {
        bufLine.unshift(line);
        break;
      }
      text = EpicLog.toText(lv, dt, scope, args);
      data += text + "\n";
      if (bufLine.length === 0) {
        break;
      }
    }
    filename = EpicLog.conf.file.filename(fileYMD);
    return fs.appendFile(filename, data, function(err) {
      lock = false;
      return _appendToFile();
    });
  };
  _writer = function(lv, dt, scope, args) {
    bufLine.push([lv, dt, scope, args]);
    return _appendToFile();
  };
  return _writer;
};

createConsoleWriter = function(conf) {
  var _coloredLv, _coloredScope, _writer, colArr, colMap, colors, filter, inx;
  if (conf == null) {
    conf = {};
  }
  colors = require('colors/safe');
  conf.filter = conf.filter || '*';
  filter = createFilter();
  filter.build(conf.filter);
  debug('filter', filter);
  colArr = 'red,green,yellow,magenta,cyan,white'.split(',');
  colMap = {};
  inx = 0;
  _coloredScope = function(scope) {
    var coloredToks, toks;
    toks = scope.split(':');
    coloredToks = toks.map(function(tok) {
      if (!colMap[tok]) {
        colMap[tok] = colArr[inx];
        inx++;
        if (inx === colArr.length) {
          inx = 0;
        }
      }
      return colors[colMap[tok]](colors.bold(tok));
    });
    return coloredToks.join(':');
  };
  _coloredLv = function(lv) {
    var c, cMap;
    cMap = {
      fatal: 'red',
      warn: 'yellow',
      info: 'cyan',
      verb: 'grey',
      log: 'grey',
      debug: 'white'
    };
    c = cMap[lv.trim()];
    return colors[c](colors.bold(lv));
  };
  _writer = function(lv, dt, scope, args) {
    var opt, ref, ref1;
    if ((lv === LV_LOG || lv === LV_VERB) && !filter.enabled(scope)) {
      return;
    }
    opt = {
      decoDate: function(dt_str) {
        return dt_str.slice(11);
      },
      decoLv: _coloredLv,
      decoScope: _coloredScope,
      decoErr: function(str) {
        return colors.red(colors.bold(str));
      },
      limitAttachLine: ((ref = EpicLog.conf) != null ? (ref1 = ref.console) != null ? ref1.limitAttachLine : void 0 : void 0) || 5,
      inspectColor: true
    };
    if (lv === LV_DEBUG) {
      opt.decoBody = function(body) {
        return colors.cyan(body);
      };
    }
    return console.log(EpicLog.toText(lv, dt, scope, args, opt));
  };
  return _writer;
};

EpicLog.writerFactory = {
  console: createConsoleWriter,
  file: createFileWriter
};

module.exports = exports = EpicLog;
